<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-touch-fullscreen" content="yes">
<meta name="format-detection" content="telephone=no, address=no">
<title>Regular Expression</title>
<link rel="icon" href="https://zhixingo.github.io/posts/regex/favicon-128.webp">
<link rel="apple-touch-icon" href="https://zhixingo.github.io/posts/regex/favicon-128.webp">
<link rel="stylesheet" type="text/css" href="https://zhixingo.github.io/posts/regex/css/common.css" media="screen">
</head>
<body>
<h1><span style="color:var(--blue)">Reg</span>ular <span style="color:var(--green)">Ex</span>pression</h1>
<p><a href="https://regexper.com/#%2F%5E%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C1%5Cd%5Cd%7C%5B1-9%5D%5Cd%7C%5Cd%29%28%3F%3A%5C.%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C1%5Cd%5Cd%7C%5B1-9%5D%5Cd%7C%5Cd%29%29%7B3%7D%24%2F">regexper</a></p>
<p><b>元字符[已省略了部分不常用的]</b></p>
<table>
	<tr><th width="100px">字符</th><th>说明</th></tr>
	<tr><td><p>\</p></td><td><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\\”匹配“\”，“\(”匹配“(”。</p></td></tr>
	<tr><td><p>^</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/anchors.jpg" /> 匹配输入字符串开始的位置，在<img src="https://zhixingo.github.io/posts/regex/img/characterclass.jpg" />中表示排除。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b>(多行) 属性，^ 还会与“\n”或“\r”之后的位置匹配。</p></td></tr>
	<tr><td><p>$</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/anchors.jpg" /> 匹配输入字符串结尾的位置。如果设置了 <b>RegExp</b> 对象的 <b>Multiline</b>(多行)属性，$ 还会与“\n”或“\r”之前的位置匹配。</p></td></tr>
	<tr><td><p>+</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> <strong>量词[1~n次]</strong>一次或多次匹配前面的字符或子表达式。</p></td></tr>
	<tr><td><p>*</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> <strong>量词[0~n次]</strong>零次或多次匹配前面的字符或子表达式。</p></td></tr>
	<tr><td><p>?</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> <strong>量词[0/1次]</strong>零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中。 等效于 {0,1}。</p></td></tr>
	<tr><td><p>{<i>n</i>}</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> 量词匹配正好 <i>n</i> 次。</p></td></tr>
	<tr><td><p>{<i>n</i>,}</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> 量词匹配至少 <i>n</i> 次。</p></td></tr>
	<tr><td><p>{<i>n</i>,<i>m</i>}</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"/> 量词匹配至少 <i>n</i> 次，至多 <i>m</i> 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。注意：您不能将空格插入逗号和数字之间（如o{1 , 3})。</p></td></tr>		
	<tr><td><p>(<i>pattern</i>)</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/capturinggroup.jpg" />(Capturing group) 匹配 pattern 并捕获该匹配</p></td></tr>
	<tr><td><p>(?:<i>pattern</i>)</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/capturinggroup.jpg" />(Non-capturing group) 匹配 pattern 但不捕获该匹配</p></td></tr>
	<tr><td><p>xxx(?=<i>pattern</i>)</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/lookaround.jpg" />(Lookaround)执行正向预测先行搜索的子表达式，它是一个非捕获匹配，零宽度匹配。例如，'Windows (?=95|98|NT|2000)' 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。<br/>^(?=[a-z])[a-z0-9]+$能匹配a12,而^(?=[a-z])[0-9]+$不能匹配a12， 因为“(?=[a-z])”只匹配，并不将匹配到的内容保存到最后结果，“(?=[a-z])”匹配成功的位置是位置0，所以“[a-z0-9]+”也是从位置0开始尝试匹配，“[a-z0-9]+”首先尝试匹配“a”</p></td></tr>
	<tr><td><p>(?&lt;=<i>pattern</i>)xxx</p></td><td><img src="https://zhixingo.github.io/posts/regex/img/lookaround.jpg" />(Lookaround)前置</td></tr>
	<tr><td><p>xxx(?!<i>pattern</i>)</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/lookaround.jpg" />(Lookaround)执行反向预测先行搜索的子表达式，它是一个非捕获匹配，零宽度匹配。例如，'Windows (?!95|98|NT|2000)' 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。</p></td></tr>
	<tr><td><p>(?&lt;!<i>pattern</i>)xxx</p></td><td><img src="https://zhixingo.github.io/posts/regex/img/lookaround.jpg" />(Lookaround)前置</td></tr>
	<tr><td><p><i>net</i>|<i>com</i></p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/alternation.jpg" /> <strong>[或]</strong> 例如^markli\.(com|net)$ 匹配“markli.com”或“markli.net”。要匹配 |，请使用 \| </p></td></tr>
	<tr><td><p>[<i>xyz</i>]</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/characterclass.jpg" /> <strong>[字符集]</strong>匹配包含的任一字符。</p></td></tr>
	<tr><td><p>[^<i>xyz</i>]</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/characterclass.jpg" /> 反向字符集。匹配未包含的任何字符。</p></td></tr>
	<tr><td><p>[<i>a-z</i>]</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/characterclass.jpg" /> <strong>[字符范围]</strong>匹配指定范围内的任何字符。（-字符如果在字符范围前，则表示 他本身，无需转义，如果在两个字符中间，则表示两个字符的区间）例如，“[a-z]”匹配a到z范围内的任何小写字母。还有[a-zA-Z0-9]，⚠️ <note>注意 [A-z] 不等于[A-Za-z] 而是 [A-Z\[\\\]^_`a-z]，<a href="keycode.html" target="_blank">charCode 65-122</a></note></p></td></tr>
	<tr><td><p>[^<i>a-z</i>]</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/characterclass.jpg" /> 反向范围字符。匹配不在指定的范围内的任何字符</p></td></tr>
	<tr><td><p>\b</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/anchors.jpg" /> 匹配一个字边界(border)，即字与<b>空格</b>间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。再如“\byo”匹配“I love you”第三个字you的yo</p></td></tr>
	<tr><td><p>\B</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/anchors.jpg" /> 非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。 </p></td></tr>
	<tr><td><p>\d</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> <strong>[数字]</strong>数字字符匹配。等效于 [0-9]。 </p></td></tr>
	<tr><td><p>\D</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> <strong>[非数字]</strong>非数字字符匹配。等效于 [^0-9]。</p></td></tr>
	<tr><td><p>.</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 匹配除换行“\n”之外的任何单个字符。</p></td></tr>
	<tr><td><p>\n</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 换行符(newline)匹配。</p></td></tr>
	<tr><td><p>\r</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 匹配一个回车符(return)。</p></td></tr>
	<tr><td><p>\s</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 匹配任何空白字符，包括空格（space)、制表符、换页符等.与[&nbsp;\f\n\r\t\v]等效。</p></td></tr>
	<tr><td><p>\S</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 匹配任何非空白字符。与 [^&nbsp;\f\n\r\t\v] 等效。</p></td></tr>
	<tr><td><p>\w</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> <strong>[字母数字下划线]</strong>匹配any word character，包括下划线。与“[A-Za-z0-9_]”等效。</p></td></tr>
	<tr><td><p>\W</p></td><td><p><img src="https://zhixingo.github.io/posts/regex/img/character.jpg" /> 与任何非word character匹配。与“[^A-Za-z0-9_]”等效</p></td></tr>
	<tr><td><p>\x<i>n</i></p></td><td><p>此处的 <i>n</i> 是一个十六进制转义码。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</p></td></tr>
</table>
<p><b>正则表达式的引擎</b></p>
当发现复制来的正则在JavaScript里正常，而在PHP却无法使用的时候，为什么会这样，慢慢的你就知道正则流派与引擎了<br/>
<table>
<tr><th>引擎类型</th><th>程序</th></tr>
<tr><td>DFA</td><td>Awk(多数版本)、egrep(多数版本)、flex、lex、Mysql</td></tr>
<tr><td>POSIX NFA</td><td></td></tr>
<tr><td>传统NFA</td><td>GUN Emacs、JAVA、GREP(多数版本)、less、more、PREL、PHP(3套)、Python、ruby、sed(多数版本)、vi</td></tr>
<tr><td>DFA/NFA混合</td><td>Gun awk、gun grep/egrep</td></tr>
</table>
<span style="font-size:20px;color:#000;">&spades;</span> <strong>DFA引擎</strong>不需要回溯(Backtracking)，所以匹配快速，也不支持捕获组（所以也就不支持后向引用和$number这种引用方式)<br/>
<img src="https://zhixingo.github.io/posts/regex/img/look-back-upon.jpg" /><br/>
<span style="font-size:20px;color:#000;">&clubs;</span> <strong>POSIX NFA</strong>主要指符合<a href="http://zh.wikipedia.org/wiki/POSIX" target="_blank">POSIX</a>标准的NFA引擎，它的特点主要是提供<b>longest-leftmost匹配</b>，也就是在找到最左侧最长匹配之前，它将继续回溯。<br/>非贪婪模式（或者说忽略优先量词，<em>匹配优先量词和忽略优先量词</em>实际上也就是我们说的正则表达式中的<em>贪婪模式和非贪婪模式</em>）对于POSIX NFA同DFA一样,是没有意义的。<br/>
<span style="font-size:20px;color:red;">&diams;</span> <strong>传统NFA引擎</strong> - 大多数语言和工具使用的，它有一些DFA不支持的特性：<br/>
1.捕获组、后向引用和$number引用方式<br/>
2.Lookaround: <img src="https://zhixingo.github.io/posts/regex/img/lookaround.jpg"> (?=…)、(?!…)、(?&lt;=…)、(?&lt;!…)<br/>
3.忽略优先量词: <img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"> ??、*?、+?、{m,n}?、{m,}?  默认的是匹配优先量词,与匹配优先量词相反,忽略优先量词的意思是尽可能少的匹配<br/>
4.占有优先量词: <img src="https://zhixingo.github.io/posts/regex/img/quantifier.jpg"> ?+、*+、++、{m,n}+、{m,}+，匹配优先最终不成功还可回溯为忽略，但占有优先一旦匹配就封住退路，不准回溯，目前仅Java和PCRE支持(php有pcre)<br/>
5.固化分组 Atomic Grouping(?&gt;…)<br/>
<br/>
<strong>NFA引擎</strong>是<em>“猴急”的，它会很急切的进行表功</em>，报告它找到的第一个匹配 <br/>
你可以作如下测试：将正则表达式"(regex|regex not)"应用到字符串"regex not"。如果匹配的结果是regex，则引擎是NFA。如果结果是regex not，则是DFA。NFA找到后锁定，返回。DFA继续下一个，找最长结果<br/>
<pre class="code">
preg_match('/date:(\d{4}|\d{4}-\d{2}-\d{2})/','date:2016-05-19',$match);
echo $match[1]; <span class="comment">// 输出的结果是2016,所以PHP用的是NFA引擎</span>

preg_match('/(&lt;div&gt;.+&lt;/div&gt;)/','&lt;div&gt;testtest&lt;/div&gt; &lt;div&gt;test&lt;/div&gt;',$match);
echo htmlspecialchars($match[1]); <span class="comment">// +是默认的匹配优先量词 结果是 &lt;div&gt;testtest&lt;/div&gt; &lt;div&gt;test&lt;/div&gt;</span>

preg_match('/(&lt;div&gt;.+?&lt;/div&gt;)/','&lt;div&gt;testtest&lt;/div&gt; &lt;div&gt;test&lt;/div&gt;',$match);
echo htmlspecialchars($match[1]); <span class="comment">// +?是忽略优先量词 结果是&lt;div&gt;testtest&lt;/div&gt;</span>

preg_match('/(ab??)/','ab',$match);
echo $match[1]; <span class="comment">// 忽略优先,结果是a, 如果是(ab?) 结果是ab</span>

preg_match('/(ab??c)/','abc',$match);
echo $match[1]; <span class="comment">// 结果是abc,why?先忽略优先最终匹配不了字符，然后回溯匹配b,最后成功匹配</span>
</pre>
<strong>固化分组和占有量词</strong><br/>
假设我们有这样的需要，把类似 3.690000023 的小数保留两位小数，类似 2.3563895 的小数保留三位小数，也就是说如果小数的第三位是 0， 则保留两位小数，如果是非 0， 就保留三位小数<br/>
<pre class="code">
echo preg_replace('/(\.\d\d[1-9]?)\d*/','$1',$number)
<span class="comment">//这个是可以完成任务，但美中不足的是当 $number 类似 1.234 的数字，白白处理了一遍。为了提升效率，我们把表达式稍稍修改一下。</span>

echo preg_replace('/(\.\d\d[1-9]?)\d+/','$1',$number)
<span class="comment">//为了使其不匹配正好三位的1.234,将d*改成d+，却发现.234被替换成了.23，因为引擎回溯，[1-9]? 把匹配的数字吐出去，4被\d+匹配了。有两种办法可以强迫引擎放弃回溯：固化分组和占有量词</span>

echo preg_replace('/(\.\d\d(?>[1-9]?))\d+/','$1',$number); 
<span class="comment">//固化分组，匹配进行到此结构之后（闭括号之后），那么此结构体中的所有回溯的备选状态都会被放弃(迷宫退路关闭)</span>

echo preg_replace('/(\.\d\d[1-9]?+)\d+/','$1',$number);
<span class="comment">//占有量词，能匹配先匹配，匹配了不准回溯(迷宫退路关闭)</span>
</pre>
<b>太多的回溯会使得你的程序阻塞</b><br/>
字符串:&lt;div&gt;xxxxx…xxxx&lt;/div&gt;&lt;div&gt;test&lt;/div&gt;(...处是10W个字符)<br/>
表达式:&lt;div&gt;.+?&lt;/div&gt;<br/>
当遇到忽略优先量词+?，中间每个字符处都记录一个备选状态，对于10W个字符，会占用相当大的内存<br/>回溯次数多，PHP的堆栈溢出，好在有回溯次数限制(pcre.backtrack_limit)，不然或许又成为一个溢出漏洞了<br/>
<img src="https://zhixingo.github.io/posts/regex/img/backtracking_limit.jpg" />
<p><b>正则表达式性能设计</b></p>
<strong>1.先大后细</strong><br/>
举手机号的例子，先界定\d{11}；再细化为1[358]\d{9}，逐步细化,一点一点地消除误匹配（做减法）<br/>
<strong>2.环保不浪费</strong><br/>
只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。<br/>每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。<br/>
<strong>3.少用多选分支</strong><br/>
c[a-f]t 与c(a|b|c|d|e|f)t (有6次回溯)<br/>
<strong>4.适当使用边界字符</strong><br/>
^,$,\b<br/>
<strong>5.分支顺序</strong><br/>
最可能出现的放到分支最前面
<p><b>常用例子</b></p>
<table>
	<tr><th>正则表达式</th><th>匹配内容</th><th><a href="https://regexper.com/#%2F%5E%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C1%5Cd%5Cd%7C%5B1-9%5D%5Cd%7C%5Cd%29%28%3F%3A%5C.%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5Cd%7C1%5Cd%5Cd%7C%5B1-9%5D%5Cd%7C%5Cd%29%29%7B3%7D%24%2F" target="_blank">regexper</a></th></tr>
	<tr><td><p>/^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$/</td><td><b>Validate IP address</b></td><td><img src="https://zhixingo.github.io/posts/regex/img/validate_ip_address.png"/></td></tr>
    <tr><td><p>/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/</p></td><td><a href="https://www.w3.org/TR/html5/forms.html#valid-e-mail-address" target="_blank">Validate Email address(W3C HTML5 spec)</a></td><td><a href="https://zhixingo.github.io/posts/regex/img/regex_issue.jpg" target="_blank">Alexa email regex issue</a></td></tr>
	<tr><td><p>/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/</p></td><td><b>Validate URL</b><br>反向匹配URL，/(\w+)可匹配HTTP 然后:\/\/匹配:// 然后是[^/:]+，即非/:的字符匹配中间域名然后是(:\d*)?非贪心匹配端口号,然后匹配不包括 # 或空格字符的任何字符序列</td><td></td></tr>
	<tr><td><p>/^\d{6,8}$/</p></td><td>只能输入6~8位的数字</td><td></td></tr>
	<tr><td><p>/^[0-9-]+$/</p></td><td>只能输入数字和-</td><td></td></tr>
</table>
<p><b>vim 替换</b></p>
<p>vim 的替换需要另外的转义 \+, \{n,m}, \(</p>
<pre class="code">
:%s/[a-z]\+[^a-z,]{2,}\([a-z]\)/\1/g
</pre>
  <div class="copy" style="text-align:left">Copyright &copy; 2015-<script>document.write(new Date().getFullYear())</script> <a href="https://markbuild.com/" target="_blank">markbuild</a></div>
</body>
</html>
